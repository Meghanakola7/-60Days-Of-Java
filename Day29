Topics:Time and space complexity

1.Bubble sort Alogithm:
The Bubble Sort algorithm is a simple sorting technique that repeatedly compares adjacent elements and swaps them if they are in the wrong order. 

Ex:
import java.util.Scanner;
class BubbleSort {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}

Time complexity:O(n^2)
Space complexity:O(1)

2.Insertion Sort:
Insertion Sort is a comparison based sorting algorithm that builds the final sorted array one element at a time.
It works by taking one element from the input array and inserting it into its correct position in the sorted part of the array.
Algorithm:
for i = 1 to n-1:
key = array[i]
j = i - 1
while j >= 0 and array[j] > key:
array[j + 1] = array[j]
j = j - 1
array[j + 1] = key

Time Complexity:O(n^2)
Space complexity:O(1)

3.Quick sort 
QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. 
There are many different versions of QuickSort that pick pivot in different ways:
a.Always pick first element as pivot.
b.Always pick last element as pivot (implemented below)
c.Pick a random element as pivot.
d.Pick median as pivot.

Algorithm:
class QuickSort {
int partition(int arr[], int low, int high) {
int pivot = arr[high];  
int i = low - 1;  
for (int j = low; j < high; j++) {
if (arr[j] <= pivot) {
i++;
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
}
int temp = arr[i + 1];
arr[i + 1] = arr[high];
arr[high] = temp;
 return i + 1;
}
void quickSort(int arr[], int low, int high) {
if (low < high) {
int pi = partition(arr, low, high);
quickSort(arr, low, pi - 1);  
quickSort(arr, pi + 1, high); 
        } 
    }
}

Time Complexity:O(n^2) for worst and O(n log n) for average
Space Complexity:O(log n)

4.Merge sort:
